"""PJSIP configuration file generator."""

import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)


class PJSIPGenerator:
    """
    Generates Asterisk PJSIP configuration for SIP endpoints.

    Creates endpoint, auth, and aor (Address of Record) blocks for each extension.
    """

    @staticmethod
    def generate_config(users_with_extensions: List[Dict[str, Any]]) -> str:
        """
        Generate PJSIP configuration content for all users/extensions.

        Args:
            users_with_extensions: List of user dictionaries, each containing:
                - id: User UUID
                - name: User name
                - email: User email
                - extension: Dict with number, secret, etc.

        Returns:
            String containing complete PJSIP configuration in Asterisk format

        Example output:
            ; PJSIP Endpoints - Auto-generated by PBX Control Portal
            ; DO NOT EDIT MANUALLY - Changes will be overwritten on next apply

            [1000](!)
            type=endpoint
            context=synergy-internal
            disallow=all
            allow=ulaw
            allow=alaw
            auth=1000
            aors=1000

            [1000](!)
            type=auth
            auth_type=userpass
            username=1000
            password=a8K3mP9xQ2vR7wN5

            [1000](!)
            type=aor
            max_contacts=3
            remove_existing=yes
        """
        if not users_with_extensions:
            logger.warning("No users provided to PJSIP generator, generating empty config")
            return PJSIPGenerator._generate_header()

        logger.info(f"Generating PJSIP config for {len(users_with_extensions)} users")

        lines = [PJSIPGenerator._generate_header()]

        for user in users_with_extensions:
            extension = user.get("extension")
            if not extension:
                logger.warning(f"User {user.get('id')} has no extension, skipping PJSIP config")
                continue

            extension_number = extension.get("number")
            secret = extension.get("secret")

            if not extension_number or not secret:
                logger.warning(
                    f"User {user.get('id')} missing extension number or secret, skipping"
                )
                continue

            # Generate endpoint, auth, and aor blocks for this extension
            lines.append(PJSIPGenerator._generate_endpoint(extension_number))
            lines.append(PJSIPGenerator._generate_auth(extension_number, secret))
            lines.append(PJSIPGenerator._generate_aor(extension_number))
            lines.append("")  # Blank line between extensions

        config = "\n".join(lines)
        logger.info(f"PJSIP config generated: {len(lines)} lines")
        return config

    @staticmethod
    def _generate_header() -> str:
        """Generate configuration file header with warnings."""
        return """; PJSIP Endpoints - Auto-generated by PBX Control Portal
; DO NOT EDIT MANUALLY - Changes will be overwritten on next apply
; Generated extensions are in range 1000-1999
;
; Configuration structure:
;   [extension] - endpoint (SIP settings)
;   [extension] - auth (authentication credentials)
;   [extension] - aor (address of record / registration)
"""

    @staticmethod
    def _generate_endpoint(extension_number: int) -> str:
        """
        Generate endpoint section for an extension.

        The endpoint defines SIP protocol settings for the extension.
        """
        return f"""[{extension_number}]
type=endpoint
context=default
disallow=all
allow=ulaw
allow=alaw
auth=auth-{extension_number}
aors=aor-{extension_number}"""

    @staticmethod
    def _generate_auth(extension_number: int, secret: str) -> str:
        """
        Generate auth section for an extension.

        The auth section contains authentication credentials.
        """
        return f"""[auth-{extension_number}]
type=auth
auth_type=userpass
username={extension_number}
password={secret}"""

    @staticmethod
    def _generate_aor(extension_number: int) -> str:
        """
        Generate aor (Address of Record) section for an extension.

        The AOR defines registration and contact handling.
        """
        return f"""[aor-{extension_number}]
type=aor
max_contacts=3
remove_existing=yes"""
