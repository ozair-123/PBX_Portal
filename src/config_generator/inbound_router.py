"""Inbound DID routing generator for Asterisk dialplan."""

import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)


class InboundRouter:
    """
    Generate Asterisk dialplan for inbound DID routing.

    Routes incoming calls from DIDs (Direct Inward Dialing numbers) to:
    - User extensions
    - IVR menus
    - Voicemail
    - External numbers
    - Ring groups
    """

    @staticmethod
    def generate(
        dids: List[Dict[str, Any]] = None,
        users: List[Dict[str, Any]] = None,
        did_assignments: List[Dict[str, Any]] = None
    ) -> str:
        """
        Generate inbound routing dialplan configuration.

        Args:
            dids: (Legacy) List of DID configuration dicts
            users: List of user dicts for lookups
            did_assignments: List of DID assignment dicts with keys:
                - number: str (E.164 format, e.g., +15551234567)
                - assigned_type: str (USER, IVR, QUEUE, EXTERNAL)
                - assigned_id: str (UUID for USER/IVR/QUEUE)
                - assigned_value: str (dialplan context for EXTERNAL)
                - tenant_id: str
                - tenant_context: str (for USER routing)
                - extension: int (for USER routing)

        Returns:
            str: Asterisk dialplan configuration with [from-trunk-external] context

        Example:
            >>> did_assignments = [
            ...     {"number": "+15551234567", "assigned_type": "USER",
            ...      "extension": 1001, "tenant_context": "tenant-acme"}
            ... ]
            >>> config = InboundRouter.generate(did_assignments=did_assignments, users=[])
        """
        # Use new did_assignments parameter if provided, otherwise fall back to legacy
        if did_assignments is not None:
            return InboundRouter._generate_from_assignments(did_assignments, users or [])
        else:
            return InboundRouter._generate_legacy(dids or [], users or [])

    @staticmethod
    def _generate_from_assignments(did_assignments: List[Dict[str, Any]], users: List[Dict[str, Any]]) -> str:
        """
        Generate [from-trunk-external] context with DID routing.

        Routes incoming calls based on DID assignments:
        - USER: Routes to tenant context and extension
        - EXTERNAL: Executes custom dialplan logic

        Args:
            did_assignments: List of DID assignment dicts
            users: List of user dicts for lookups

        Returns:
            str: Asterisk dialplan for [from-trunk-external] context
        """
        config_lines = []

        # Header
        config_lines.append("; ========================================")
        config_lines.append("; Inbound DID Routing (from-trunk-external)")
        config_lines.append("; Generated by PBX Portal Apply")
        config_lines.append("; ========================================")
        config_lines.append("")

        # Create [from-trunk-external] context for inbound calls
        config_lines.append("[from-trunk-external]")
        config_lines.append("; Incoming calls from SIP trunk")
        config_lines.append("")

        # If no DID assignments, add empty context comment
        if not did_assignments:
            config_lines.append("; No DID assignments configured")
            config_lines.append("")
            return "\n".join(config_lines)

        # Generate routing for each DID assignment
        for assignment in did_assignments:
            number = assignment.get("number", "")
            assigned_type = assignment.get("assigned_type", "")
            assigned_id = assignment.get("assigned_id")
            assigned_value = assignment.get("assigned_value")
            tenant_context = assignment.get("tenant_context")
            extension = assignment.get("extension")

            if assigned_type == "USER":
                # Route to tenant context and extension
                # Pattern: exten => +NUMBER,1,Goto(tenant-context,extension,1)
                if tenant_context and extension:
                    config_lines.append(f"; Route {number} to user extension {extension}")
                    config_lines.append(f"exten => {number},1,Goto({tenant_context},{extension},1)")
                    config_lines.append("")
                else:
                    logger.warning(f"USER assignment for {number} missing tenant_context or extension")

            elif assigned_type == "EXTERNAL":
                # Execute custom dialplan logic
                # Pattern: exten => +NUMBER,1,{assigned_value}
                if assigned_value:
                    config_lines.append(f"; Route {number} to external dialplan")
                    config_lines.append(f"exten => {number},1,{assigned_value}")
                    config_lines.append("")
                else:
                    logger.warning(f"EXTERNAL assignment for {number} missing assigned_value")

            elif assigned_type in ["IVR", "QUEUE"]:
                # Future: Route to IVR or Queue
                config_lines.append(f"; Route {number} to {assigned_type} (not yet implemented)")
                config_lines.append(f"exten => {number},1,NoOp({assigned_type} routing TBD)")
                config_lines.append("")

        # Fallback for unmatched DIDs
        config_lines.append("; Fallback for unmatched numbers")
        config_lines.append("exten => _X.,1,NoOp(Unmatched DID: ${EXTEN})")
        config_lines.append("same => n,Playback(ss-noservice)")
        config_lines.append("same => n,Hangup()")
        config_lines.append("")

        return "\n".join(config_lines)

    @staticmethod
    def _generate_legacy(dids: List[Dict[str, Any]], users: List[Dict[str, Any]]) -> str:
        """
        Legacy generate method for backward compatibility.

        Args:
            dids: List of DID configuration dicts
            users: List of user dicts for lookups

        Returns:
            str: Asterisk dialplan configuration
        """
        config_lines = []

        # Header
        config_lines.append("; ========================================")
        config_lines.append("; Inbound DID Routing (Legacy)")
        config_lines.append(f"; Generated: {logger.name}")
        config_lines.append("; ========================================")
        config_lines.append("")

        # Create [from-trunk] context for inbound calls
        config_lines.append("[from-trunk]")
        config_lines.append("; Incoming calls from SIP trunk")
        config_lines.append("")

        # Group DIDs by destination for efficient routing
        for did in dids:
            number = did.get("number", "").lstrip("+")
            dest_type = did.get("destination_type")
            dest_value = did.get("destination_value")

            if dest_type == "USER":
                # Route to user extension
                user = next((u for u in users if str(u.get("id")) == dest_value), None)
                if user and user.get("extension"):
                    ext = user["extension"]
                    config_lines.append(f"exten => {number},1,NoOp(Inbound call to DID {number})")
                    config_lines.append(f"same => n,Set(CALLERID(name)=Inbound to {user.get('name', 'User')})")
                    config_lines.append(f"same => n,Dial(PJSIP/{ext},30)")
                    config_lines.append(f"same => n,Voicemail({ext}@default,u)")
                    config_lines.append(f"same => n,Hangup()")
                    config_lines.append("")

            elif dest_type == "VOICEMAIL":
                # Route directly to voicemail
                config_lines.append(f"exten => {number},1,NoOp(Inbound call to DID {number} - Voicemail)")
                config_lines.append(f"same => n,Voicemail({dest_value}@default,u)")
                config_lines.append(f"same => n,Hangup()")
                config_lines.append("")

            elif dest_type == "IVR":
                # Route to IVR menu (future enhancement)
                config_lines.append(f"exten => {number},1,NoOp(Inbound call to DID {number} - IVR)")
                config_lines.append(f"same => n,Goto(ivr-{dest_value},s,1)")
                config_lines.append(f"same => n,Hangup()")
                config_lines.append("")

            elif dest_type == "EXTERNAL":
                # Route to external number
                config_lines.append(f"exten => {number},1,NoOp(Inbound call to DID {number} - External)")
                config_lines.append(f"same => n,Dial(PJSIP/{dest_value}@trunk,30)")
                config_lines.append(f"same => n,Hangup()")
                config_lines.append("")

        # Fallback for unmatched DIDs
        config_lines.append("exten => _X.,1,NoOp(Unmatched DID: ${EXTEN})")
        config_lines.append("same => n,Playback(ss-noservice)")
        config_lines.append("same => n,Hangup()")
        config_lines.append("")

        return "\n".join(config_lines)
