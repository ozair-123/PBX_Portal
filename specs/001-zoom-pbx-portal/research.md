# Research: Zoom-Style PBX Management Portal

**Date**: 2026-01-04
**Status**: Complete
**Purpose**: Resolve technical unknowns and establish best practices for implementation

## Overview

This document consolidates research findings for implementing the Zoom-Style PBX Management Portal. All technology choices from Technical Context are confirmed and production-proven. Research focuses on implementation patterns, security best practices, and Asterisk integration strategies.

## Technical Decisions Summary

All core technologies confirmed from existing working system:
- **Backend**: Python 3.12 + FastAPI 0.104+ + SQLAlchemy 2.0+
- **Databases**: PostgreSQL 16.11 (app data) + MariaDB (PJSIP Realtime)
- **Asterisk Integration**: AMI for reloads/status + CLI fallback + MariaDB Realtime for endpoints
- **Frontend**: Existing static HTML/JS (working, no framework needed)
- **Deployment**: Systemd service on Linux (Ubuntu 22.04+/Debian 12+)

No NEEDS CLARIFICATION items - all decisions made based on production requirements.

---

## 1. DID Routing Implementation Strategy

### Decision: Hybrid Approach (Database + Generated Dialplan)

**Rationale**:
- Database stores DID mappings for CRUD operations and admin UI
- Generated dialplan provides fast lookup without database roundtrip per call
- Enables atomic apply workflow (generate config â†’ validate â†’ apply)

**Implementation Pattern**:
```asterisk
; /etc/asterisk/extensions.d/synergycall/generated_inbound.conf
[portal-inbound]
; Auto-generated by portal on apply
exten => _+1NXXNXXXXXX,1,NoOp(Inbound DID: ${EXTEN})
 same => n,Set(DID=${EXTEN})
 same => n,Gosub(did-lookup,${DID},1)
 same => n,Hangup()

[did-lookup]
; DID +15550100 â†’ User 1001
exten => +15550100,1,Dial(PJSIP/1001,30)
 same => n,Voicemail(1001,u)
 same => n,Return()

; DID +15550200 â†’ Ring Group 1
exten => +15550200,1,Dial(PJSIP/1001&PJSIP/1002&PJSIP/1003,30,m)
 same => n,Voicemail(2000,u)
 same => n,Return()

; Fallback for unmapped DIDs
exten => _X.,1,Dial(PJSIP/${TENANT_DEFAULT_EXTENSION},20)
 same => n,Voicemail(${TENANT_DEFAULT_EXTENSION},u)
 same => n,Return()
```

**Alternatives Considered**:
1. **AstDB-based lookup** (`DB(did/${TENANT}/${DID})`):
   - Pro: More dynamic, no reload needed for DID changes
   - Con: Adds database lookup latency to every call
   - Con: More complex debugging (hidden state not visible in dialplan)
   - **Rejected**: Violates Constitution Principle I (file-based config preferred)

2. **AGI/ARI script lookup** (Python script per call):
   - Pro: Maximum flexibility, direct database access
   - Con: Performance overhead (process spawn per call)
   - Con: Complexity (separate service to maintain)
   - **Rejected**: Over-engineered for MVP, violates Principle VIII (Simplicity First)

**Best Practice**: Generate dialplan entries per DID on apply. Fast, debuggable, aligns with file-based philosophy.

---

## 2. Multi-Device SIP Credential Strategy

### Decision: Unique SIP Username Per Device

**Rationale**:
- Asterisk PJSIP Realtime identifies endpoints by unique ID (auth username)
- Multi-device = multiple ps_endpoints rows, all with different IDs but same AOR (contact list)
- Enables granular device control (delete device without affecting others)

**Implementation Pattern**:

**PostgreSQL (Portal Database)**:
```sql
-- devices table
CREATE TABLE devices (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    label VARCHAR(255) NOT NULL,  -- "Desk Phone", "Mobile App", etc.
    sip_username VARCHAR(255) UNIQUE NOT NULL,  -- "1001-desk", "1001-mobile"
    sip_password_encrypted TEXT NOT NULL,  -- Fernet encrypted
    transport VARCHAR(10) DEFAULT 'udp',  -- udp, tcp, ws, wss
    nat_flags_json JSONB,  -- {rewrite_contact: true, rtp_symmetric: true, force_rport: true}
    codecs_json JSONB,  -- {allow: ["ulaw", "alaw"], disallow: ["all"]}
    created_at TIMESTAMP DEFAULT NOW()
);
```

**MariaDB (PJSIP Realtime)**:
```sql
-- User 1001 with 2 devices: Desk Phone + Mobile App

-- ps_endpoints (one per device)
INSERT INTO ps_endpoints (id, transport, aors, auth, context, disallow, allow, callerid)
VALUES
  ('1001-desk', 'transport-udp', '1001', '1001-desk', 'portal-internal', 'all', 'ulaw,alaw', '"John Doe" <1001>'),
  ('1001-mobile', 'transport-udp', '1001', '1001-mobile', 'portal-internal', 'all', 'ulaw,alaw', '"John Doe" <1001>');

-- ps_auths (one per device)
INSERT INTO ps_auths (id, auth_type, username, password)
VALUES
  ('1001-desk', 'userpass', '1001-desk', 'SecurePass1'),
  ('1001-mobile', 'userpass', '1001-mobile', 'SecurePass2');

-- ps_aors (ONE shared AOR for all devices)
INSERT INTO ps_aors (id, max_contacts, remove_existing)
VALUES ('1001', 10, 'no');  -- Allow up to 10 simultaneous registrations
```

**Call Routing**: Both devices ring simultaneously via AOR
```asterisk
[portal-internal]
exten => 1001,1,Dial(PJSIP/1001,30)  ; Rings ALL registered devices in AOR '1001'
```

**Alternatives Considered**:
1. **Same SIP credentials, multiple registrations**:
   - Pro: Simpler credential management
   - Con: Cannot revoke individual device access (delete one device kills all)
   - Con: Harder to track which device is which in AMI status
   - **Rejected**: Violates FR-007 (multiple devices per user) granularity requirement

2. **Separate extensions per device** (1001, 1001-1, 1001-2):
   - Pro: Each device has unique extension
   - Con: User confusion (which number to give out?)
   - Con: Complex call forwarding logic
   - **Rejected**: Not user-friendly, doesn't match Zoom model

**Best Practice**: Unique SIP username per device, shared AOR for simultaneous ring.

---

## 3. SIP Password Encryption Strategy

### Decision: Fernet Symmetric Encryption (cryptography library)

**Rationale**:
- Must be reversible (need plaintext to write to MariaDB ps_auths)
- Bcrypt/Argon2 are one-way hashes (not suitable for SIP passwords)
- Fernet provides authenticated encryption (AES-128-CBC + HMAC)
- Key stored in environment variable (never in code or database)

**Implementation**:
```python
from cryptography.fernet import Fernet
import os

# Key generation (ONE TIME, store in .env)
# key = Fernet.generate_key()  # Store as FERNET_KEY in .env

class SIPPasswordManager:
    def __init__(self):
        key = os.getenv("FERNET_KEY")
        if not key:
            raise ValueError("FERNET_KEY environment variable not set")
        self.cipher = Fernet(key.encode())

    def encrypt(self, plaintext: str) -> str:
        """Encrypt SIP password for storage"""
        return self.cipher.encrypt(plaintext.encode()).decode()

    def decrypt(self, ciphertext: str) -> str:
        """Decrypt SIP password for MariaDB sync"""
        return self.cipher.decrypt(ciphertext.encode()).decode()
```

**Alternatives Considered**:
1. **Store plaintext SIP passwords**:
   - **Rejected**: Massive security violation, fails FR-010

2. **Hash SIP passwords (bcrypt/argon2)**:
   - **Rejected**: Can't write to MariaDB ps_auths (need plaintext for SIP digest auth)

3. **Asymmetric encryption (RSA)**:
   - Pro: Public key encryption, private key decryption
   - Con: Overkill for this use case, slower than Fernet
   - **Rejected**: Unnecessary complexity

**Best Practice**: Fernet for SIP passwords, Argon2 for user login passwords.

---

## 4. Outbound Policy Enforcement Pattern

### Decision: Dialplan-Based Pattern Matching with Trunk Failover

**Rationale**:
- Policy rules stored in PostgreSQL as JSON
- On apply, generate dialplan with pattern matching logic
- Fast, debuggable, no database lookup per call

**Implementation Pattern**:

**PostgreSQL Schema**:
```json
{
  "outbound_policy": {
    "name": "US Local + 911",
    "rules": [
      {
        "pattern": "911",
        "action": "allow",
        "trunk_priority": ["trunk-primary", "trunk-backup"],
        "transform": null
      },
      {
        "pattern": "_1NXXNXXXXXX",
        "action": "allow",
        "trunk_priority": ["trunk-primary", "trunk-backup"],
        "transform": {"strip_prefix": "1"}
      },
      {
        "pattern": "_011.",
        "action": "deny",
        "message": "International calls not permitted"
      }
    ]
  }
}
```

**Generated Dialplan**:
```asterisk
; /etc/asterisk/extensions.d/synergycall/generated_outbound.conf
[portal-outbound]
; Policy: US Local + 911

; Rule 1: Emergency (911)
exten => 911,1,NoOp(Emergency call - allowing)
 same => n,Dial(PJSIP/${EXTEN}@trunk-primary,30)
 same => n,GotoIf($["${DIALSTATUS}" = "CHANUNAVAIL"]?backup)
 same => n,Hangup()
 same => n(backup),Dial(PJSIP/${EXTEN}@trunk-backup,30)
 same => n,Hangup()

; Rule 2: US Calls (1-NXX-NXX-XXXX)
exten => _1NXXNXXXXXX,1,NoOp(US call - stripping 1)
 same => n,Set(CLEANED=${EXTEN:1})  ; Strip leading 1
 same => n,Dial(PJSIP/${CLEANED}@trunk-primary,30)
 same => n,GotoIf($["${DIALSTATUS}" = "CHANUNAVAIL"]?backup)
 same => n,Hangup()
 same => n(backup),Dial(PJSIP/${CLEANED}@trunk-backup,30)
 same => n,Hangup()

; Rule 3: International Calls (011...)
exten => _011.,1,NoOp(International call - blocked by policy)
 same => n,Playback(ss-noservice)
 same => n,Hangup()

; Default: Deny
exten => _X.,1,NoOp(No matching policy - denied)
 same => n,Playback(ss-noservice)
 same => n,Hangup()
```

**Alternatives Considered**:
1. **Database lookup per call** (AGI script):
   - **Rejected**: Performance overhead, violates Principle I (file-based)

2. **AstDB-based policy**:
   - **Rejected**: Hidden state, harder to debug, violates Principle I

**Best Practice**: Generate dialplan from policy JSON. Fast, transparent, version-controlled.

---

## 5. JWT Authentication & RBAC Strategy

### Decision: FastAPI Depends() + JWT Access Tokens

**Rationale**:
- FastAPI dependency injection for auth checks on every endpoint
- JWT tokens (short expiry: 1 hour, refresh tokens: 7 days)
- Role-based decorators for granular access control

**Implementation Pattern**:
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from datetime import datetime, timedelta

security = HTTPBearer()

ROLES = {
    "platform_admin": 4,  # Highest privilege
    "tenant_admin": 3,
    "support": 2,
    "end_user": 1
}

def create_access_token(user_id: str, role: str, tenant_id: str) -> str:
    expire = datetime.utcnow() + timedelta(hours=1)
    payload = {
        "sub": user_id,
        "role": role,
        "tenant_id": tenant_id,
        "exp": expire
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=["HS256"])
        return {
            "user_id": payload["sub"],
            "role": payload["role"],
            "tenant_id": payload["tenant_id"]
        }
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def require_role(minimum_role: str):
    """Decorator factory for role-based access control"""
    def role_checker(current_user: dict = Depends(get_current_user)):
        if ROLES.get(current_user["role"], 0) < ROLES.get(minimum_role, 999):
            raise HTTPException(status_code=403, detail="Insufficient permissions")
        return current_user
    return role_checker

# Usage in API
@router.post("/users")
async def create_user(
    user_data: UserCreate,
    current_user: dict = Depends(require_role("tenant_admin"))
):
    # Only tenant_admin or platform_admin can create users
    ...
```

**Alternatives Considered**:
1. **Session-based auth (cookies)**:
   - Pro: Simpler for web UI
   - Con: Doesn't work well for API clients (mobile apps, CLI tools)
   - **Rejected**: JWT more flexible for future mobile app integration

2. **OAuth2 (third-party providers)**:
   - **Rejected**: MVP doesn't need Google/Microsoft SSO, adds complexity

**Best Practice**: JWT with role-based decorators. Simple, stateless, scalable.

---

## 6. Asterisk AMI Integration Best Practices

### Decision: Persistent AMI Connection with Reconnect Logic

**Rationale**:
- AMI connection for real-time device status queries (FR-009)
- Need to handle Asterisk restarts gracefully
- Connection pool not needed (single persistent connection sufficient)

**Implementation Pattern**:
```python
import asyncio
from asterisk.ami import AMIClient, AMIClientAdapter
from contextlib import asynccontextmanager

class AsteriskAMIService:
    def __init__(self, host: str, port: int, username: str, secret: str):
        self.host = host
        self.port = port
        self.username = username
        self.secret = secret
        self.client = None
        self._lock = asyncio.Lock()

    async def connect(self):
        """Establish AMI connection with retry logic"""
        retry_count = 0
        while retry_count < 3:
            try:
                self.client = AMIClient(address=self.host, port=self.port)
                await self.client.connect()
                await self.client.login(username=self.username, secret=self.secret)
                logger.info("AMI connected successfully")
                return
            except Exception as e:
                retry_count += 1
                logger.warning(f"AMI connection attempt {retry_count} failed: {e}")
                await asyncio.sleep(2 ** retry_count)  # Exponential backoff
        raise RuntimeError("Failed to connect to Asterisk AMI after 3 attempts")

    async def get_endpoint_status(self, endpoint: str) -> dict:
        """Query PJSIP endpoint status"""
        async with self._lock:
            if not self.client or not self.client.logged_in:
                await self.connect()

            try:
                response = await self.client.send_action({
                    "Action": "PJSIPShowEndpoint",
                    "Endpoint": endpoint
                })
                return self._parse_endpoint_response(response)
            except Exception as e:
                logger.error(f"AMI query failed: {e}")
                self.client = None  # Force reconnect on next call
                raise

# Usage
ami_service = AsteriskAMIService(
    host="localhost",
    port=5038,
    username=os.getenv("AMI_USERNAME"),
    secret=os.getenv("AMI_SECRET")
)

@router.get("/devices/{device_id}/status")
async def get_device_status(device_id: UUID):
    device = db.query(Device).filter(Device.id == device_id).first()
    status = await ami_service.get_endpoint_status(device.sip_username)
    return status
```

**Alternatives Considered**:
1. **CLI-based status queries** (`asterisk -rx "pjsip show endpoint ..."`):
   - Pro: No AMI credentials needed
   - Con: Subprocess spawn overhead (slow)
   - Con: Parsing text output (fragile)
   - **Rejected**: Too slow for real-time status (violates SC-027: 10 second response time)

2. **New AMI connection per request**:
   - **Rejected**: Connection overhead, TCP handshake per query

**Best Practice**: Persistent AMI connection with reconnect logic + asyncio lock for thread safety.

---

## 7. Apply Workflow Validation Strategy

### Decision: Pre-Apply Validation Phase (FR-025)

**Rationale**:
- Detect conflicts BEFORE writing configs or reloading Asterisk
- Prevents partial applies that leave system in broken state
- Enables user-friendly error messages

**Validation Checklist**:
1. **Extension uniqueness**: No duplicate extensions within tenant
2. **DID format**: All DIDs match E.164 format (`^\\+[1-9]\\d{1,14}$`)
3. **DID destination exists**: All DID destinations reference valid users/queues/IVRs
4. **Trunk reachability**: All trunks in outbound policies exist and are enabled
5. **Dialplan syntax**: Generated dialplan passes `asterisk -rx "dialplan reload"` dry-run
6. **SIP credential uniqueness**: No duplicate SIP usernames across devices

**Implementation Pattern**:
```python
class ApplyValidator:
    def validate_all(self, session: Session, tenant_id: UUID) -> List[str]:
        """
        Run all validation checks before apply.
        Returns list of error messages (empty = valid).
        """
        errors = []

        # Check 1: Extension uniqueness
        extensions = session.query(Extension.number).filter(
            Extension.tenant_id == tenant_id
        ).all()
        if len(extensions) != len(set(extensions)):
            errors.append("Duplicate extensions detected")

        # Check 2: DID format
        dids = session.query(DID).filter(DID.tenant_id == tenant_id).all()
        for did in dids:
            if not re.match(r"^\\+[1-9]\\d{1,14}$", did.did_number):
                errors.append(f"Invalid DID format: {did.did_number}")

        # Check 3: DID destination exists
        for did in dids:
            if did.destination_type == "USER":
                user = session.query(User).filter(User.id == did.destination_target).first()
                if not user:
                    errors.append(f"DID {did.did_number} references non-existent user")

        # Check 4: Trunk reachability
        policies = session.query(OutboundPolicy).filter(
            OutboundPolicy.tenant_id == tenant_id
        ).all()
        for policy in policies:
            for rule in policy.rules_json.get("rules", []):
                for trunk_name in rule.get("trunk_priority", []):
                    trunk = session.query(Trunk).filter(Trunk.name == trunk_name).first()
                    if not trunk or not trunk.enabled:
                        errors.append(f"Policy {policy.name} references unavailable trunk: {trunk_name}")

        # Check 5: SIP username uniqueness
        sip_usernames = session.query(Device.sip_username).all()
        if len(sip_usernames) != len(set(sip_usernames)):
            errors.append("Duplicate SIP usernames detected")

        return errors

# In apply_service.py
def apply_configuration(session: Session, triggered_by: str):
    # Step 1: Validation (NEW)
    validator = ApplyValidator()
    errors = validator.validate_all(session, tenant_id)
    if errors:
        raise ValueError(f"Apply validation failed: {'; '.join(errors)}")

    # Step 2: Acquire lock (existing)
    ...

    # Step 3: Generate configs (existing)
    ...
```

**Best Practice**: Validate early, fail fast. Never start apply if validation fails.

---

## 8. Database Migration Strategy

### Decision: Alembic Auto-Generate with Manual Review

**Rationale**:
- Alembic auto-detect most schema changes
- Manual review ensures no accidental data loss
- Forward-only migrations (no downgrade in production)

**Workflow**:
```bash
# 1. Define new model in src/models/device.py
class Device(Base):
    __tablename__ = "devices"
    ...

# 2. Auto-generate migration
alembic revision --autogenerate -m "Add devices table"

# 3. Review generated migration (alembic/versions/002_add_devices.py)
# - Check for accidental DROP statements
# - Add data migrations if needed
# - Verify indexes and foreign keys

# 4. Test on staging database
alembic upgrade head

# 5. Deploy to production
alembic upgrade head
```

**Best Practice**: Always review auto-generated migrations. Test on staging first.

---

## 9. Frontend Enhancement Strategy

### Decision: Progressive Enhancement (Keep Existing, Add Features Incrementally)

**Rationale**:
- Current frontend works (static HTML + vanilla JS)
- No need for React/Vue/Angular complexity for admin portal
- Add new pages as static HTML + JS modules

**Enhancement Pattern**:
```
static/
â”œâ”€â”€ index.html                  # âœ… EXISTS - Dashboard/Users page
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ devices.html            # ðŸ†• NEW - Device management page
â”‚   â”œâ”€â”€ phone-numbers.html      # ðŸ†• NEW - DID routing page
â”‚   â”œâ”€â”€ trunks.html             # ðŸ†• NEW - Trunk management page
â”‚   â”œâ”€â”€ outbound-policies.html  # ðŸ†• NEW - Policy editor page
â”‚   â”œâ”€â”€ diagnostics.html        # ðŸ†• NEW - Real-time status page
â”‚   â””â”€â”€ self-service.html       # ðŸ†• NEW - End user settings page
â”œâ”€â”€ css/
â”‚   â””â”€â”€ styles.css              # âœ… EXISTS - Extend as needed
â””â”€â”€ js/
    â”œâ”€â”€ app.js                  # âœ… EXISTS - Main dashboard logic
    â”œâ”€â”€ api-client.js           # ðŸ†• NEW - Centralized API calls (DRY)
    â”œâ”€â”€ devices.js              # ðŸ†• NEW - Device page logic
    â”œâ”€â”€ phone-numbers.js        # ðŸ†• NEW - DID page logic
    â”œâ”€â”€ trunks.js               # ðŸ†• NEW - Trunk page logic
    â”œâ”€â”€ outbound-policies.js    # ðŸ†• NEW - Policy page logic
    â””â”€â”€ diagnostics.js          # ðŸ†• NEW - Real-time status logic
```

**Alternatives Considered**:
1. **React SPA**:
   - **Rejected**: Overkill for admin portal, adds build complexity, violates Principle VIII

2. **HTMX**:
   - Pro: Server-side rendering, less JS
   - Con: Learning curve, not needed for simple CRUD forms
   - **Rejected**: Current approach works fine

**Best Practice**: Vanilla JS modules. Simple, fast, no build step.

---

## 10. Performance Optimization Strategy

### Decision: Database Indexing + Query Optimization

**Rationale**:
- Most queries filter by tenant_id â†’ index required
- DID lookup is frequent â†’ compound index on (tenant_id, did_number)
- Device status queries join users/devices â†’ index foreign keys

**Index Strategy**:
```sql
-- Tenant isolation (used in every query)
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_devices_tenant_id ON devices(tenant_id);
CREATE INDEX idx_dids_tenant_id ON dids(tenant_id);
CREATE INDEX idx_extensions_tenant_id ON extensions(tenant_id);

-- DID lookup (frequent)
CREATE UNIQUE INDEX idx_dids_tenant_did ON dids(tenant_id, did_number);

-- Foreign key lookups
CREATE INDEX idx_devices_user_id ON devices(user_id);
CREATE INDEX idx_extensions_user_id ON extensions(user_id);
CREATE INDEX idx_dids_destination ON dids(destination_type, destination_target);

-- Email uniqueness (for login)
CREATE UNIQUE INDEX idx_users_email ON users(email);

-- Audit log queries (by actor, by time range)
CREATE INDEX idx_audit_actor_timestamp ON audit_logs(actor_id, timestamp DESC);
CREATE INDEX idx_audit_entity ON audit_logs(entity_type, entity_id, timestamp DESC);
```

**Query Optimization**:
- Use `query().options(joinedload())` for relationships to avoid N+1 queries
- Paginate large result sets (limit 100 per page)
- Cache AMI status queries (60 second TTL)

**Best Practice**: Index heavily filtered columns + foreign keys. Profile slow queries with EXPLAIN ANALYZE.

---

## Research Conclusion

All technical unknowns resolved. Implementation ready to proceed to Phase 1 (Data Model & Contracts).

**Key Takeaways**:
1. **PJSIP Realtime justified** - Pragmatic exception to Constitution Principle I
2. **Dialplan-based routing** - Fast, debuggable, version-controlled
3. **Unique SIP credentials per device** - Enables granular device management
4. **JWT + RBAC** - Stateless auth, scalable to mobile apps
5. **Pre-apply validation** - Fail fast, never leave Asterisk in broken state
6. **Progressive frontend enhancement** - No framework bloat, vanilla JS works

**No Blockers**: All patterns proven in production. Ready for data model design.
